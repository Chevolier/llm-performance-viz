<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Performance Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 350px;
            background: white;
            border-right: 2px solid #eee;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .sidebar-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        .sidebar-header h2 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 1.4em;
            font-weight: bold;
        }
        
        .copyleft {
            font-size: 11px;
            color: #666;
            line-height: 1.3;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            text-align: center;
        }
        
        .copyleft a {
            color: #007bff;
            text-decoration: none;
        }
        
        .copyleft a:hover {
            text-decoration: underline;
        }
        
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        

        
        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
        
        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            align-items: end;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .comparison-list {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        
        .comparison-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }
        
        .comparison-item:last-child {
            border-bottom: none;
        }
        
        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-btn:hover {
            background: #c82333;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-wrapper {
            background: white;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart-container {
            position: relative;
            height: 420px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        

        
        /* Tree structure styles */
        .tree-container {
            margin-bottom: 20px;
        }
        
        .tree-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        
        .tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .tree-node {
            margin: 0;
            padding: 0;
        }
        
        .tree-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin: 2px 0;
            transition: background-color 0.2s;
            user-select: none;
        }
        
        .tree-item:hover {
            background-color: #f8f9fa;
        }
        
        .tree-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
        }
        
        .tree-item.expandable {
            font-weight: 600;
        }
        
        .tree-toggle {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
        }
        
        .tree-toggle.expanded::before {
            content: 'â–¼';
        }
        
        .tree-toggle.collapsed::before {
            content: 'â–¶';
        }
        
        .tree-toggle.leaf::before {
            content: 'â€¢';
            font-size: 8px;
        }
        
        .tree-children {
            list-style: none;
            padding-left: 24px;
            margin: 0;
            display: none;
        }
        
        .tree-children.expanded {
            display: block;
        }
        
        .tree-label {
            flex: 1;
            font-size: 13px;
        }
        
        .tree-count {
            font-size: 11px;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }
        
        .selected-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
        }
        
        .selected-info strong {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>LLM Performance Visualization</h2>
        </div>
        
        <div class="tree-container">
            <div class="tree-title">ðŸš€ Runtime / Instance / Model</div>
            <ul class="tree" id="runtime-tree">
                <!-- Tree structure will be populated here -->
            </ul>
        </div>
        
        <div id="selected-info" class="selected-info" style="display: none;">
            <strong>Selected:</strong><br>
            <span id="selected-text">None</span>
        </div>
        
        <div class="tree-container">
            <div class="tree-title">Token Configuration</div>
            <div class="control-group">
                <label for="input-tokens">Input Tokens:</label>
                <select id="input-tokens">
                    <option value="">Select Input Tokens...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="output-tokens">Output Tokens:</label>
                <select id="output-tokens">
                    <option value="">Select Output Tokens...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="random-tokens">Random Tokens:</label>
                <select id="random-tokens">
                    <option value="">Select Random Tokens...</option>
                </select>
            </div>
            
            <div class="button-group" style="margin-top: 15px;">
                <button class="btn btn-primary" onclick="addToComparison()">Add to Comparison</button>
                <button class="btn btn-secondary" onclick="clearComparison()">Clear All</button>
            </div>
        </div>
        
        <div id="comparison-list" class="comparison-list" style="display: none;">
            <h3>Selected Combinations:</h3>
            <div id="comparison-items"></div>
        </div>
        
        <div class="copyleft">
            <a href="https://github.com/yytdfc/llm-performance-viz" target="_blank">https://github.com/yytdfc/llm-performance-viz</a>
        </div>
    </div>
    
    <div class="main-content">

        
        <div id="loading" class="loading" style="display: none;">
            Loading data...
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="charts-container" class="charts-container">
            <!-- Charts will be generated here -->
        </div>
    </div>

    <script>
        // Global variables
        let treeData = [];
        let selectedCombinations = [];
        let charts = {};
        let currentSelection = null;
        
        // Color palette for different combinations
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
        ];
        
        // Initialize the application
        async function init() {
            try {
                await loadTreeStructure();
            } catch (error) {
                showError('Failed to initialize application: ' + error.message);
            }
        }
        
        // Load tree structure data
        async function loadTreeStructure() {
            const response = await fetch('/api/tree-structure');
            const data = await response.json();
            treeData = data.tree;
            renderTree();
        }
        
        // Render the tree structure
        function renderTree() {
            const treeContainer = document.getElementById('runtime-tree');
            treeContainer.innerHTML = '';
            
            treeData.forEach(runtimeNode => {
                const runtimeElement = createTreeNode(runtimeNode, 0);
                treeContainer.appendChild(runtimeElement);
            });
        }
        
        // Create a tree node element
        function createTreeNode(node, level) {
            const li = document.createElement('li');
            li.className = 'tree-node';
            
            const item = document.createElement('div');
            item.className = 'tree-item';
            if (node.children && node.children.length > 0) {
                item.classList.add('expandable');
            }
            
            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (node.children && node.children.length > 0) {
                toggle.classList.add('collapsed');
            } else {
                toggle.classList.add('leaf');
            }
            
            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = node.label;
            
            const count = document.createElement('span');
            count.className = 'tree-count';
            count.textContent = node.count;
            
            item.appendChild(toggle);
            item.appendChild(label);
            item.appendChild(count);
            
            // Add click handler
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                handleTreeItemClick(node, item, toggle);
            });
            
            li.appendChild(item);
            
            // Add children if they exist
            if (node.children && node.children.length > 0) {
                const childrenContainer = document.createElement('ul');
                childrenContainer.className = 'tree-children';
                
                node.children.forEach(child => {
                    const childElement = createTreeNode(child, level + 1);
                    childrenContainer.appendChild(childElement);
                });
                
                li.appendChild(childrenContainer);
            }
            
            return li;
        }
        
        // Handle tree item click
        async function handleTreeItemClick(node, itemElement, toggleElement) {
            // Handle expansion/collapse for parent nodes
            if (node.children && node.children.length > 0) {
                const childrenContainer = itemElement.parentElement.querySelector('.tree-children');
                const isExpanded = childrenContainer.classList.contains('expanded');
                
                if (isExpanded) {
                    childrenContainer.classList.remove('expanded');
                    toggleElement.classList.remove('expanded');
                    toggleElement.classList.add('collapsed');
                } else {
                    childrenContainer.classList.add('expanded');
                    toggleElement.classList.remove('collapsed');
                    toggleElement.classList.add('expanded');
                }
            }
            
            // Handle selection for model nodes (leaf nodes)
            if (node.type === 'model') {
                // Clear previous selection
                document.querySelectorAll('.tree-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });
                
                // Set new selection
                itemElement.classList.add('selected');
                currentSelection = {
                    runtime: node.runtime,
                    instance_type: node.instance_type,
                    model_name: node.model_name
                };
                
                // Update selected info display
                updateSelectedInfo();
                
                // Load token parameters for this selection
                await loadTokenParameters();
            }
        }
        
        // Update the selected info display
        function updateSelectedInfo() {
            const selectedInfo = document.getElementById('selected-info');
            const selectedText = document.getElementById('selected-text');
            
            if (currentSelection) {
                selectedText.innerHTML = `
                    <strong>Runtime:</strong> ${currentSelection.runtime}<br>
                    <strong>Instance:</strong> ${currentSelection.instance_type}<br>
                    <strong>Model:</strong> ${currentSelection.model_name}
                `;
                selectedInfo.style.display = 'block';
            } else {
                selectedInfo.style.display = 'none';
            }
        }
        
        // Load token parameters for the current selection
        async function loadTokenParameters() {
            if (!currentSelection) return;
            
            try {
                const response = await fetch(`/api/parameters?runtime=${currentSelection.runtime}&instance_type=${currentSelection.instance_type}&model_name=${encodeURIComponent(currentSelection.model_name)}`);
                const params = await response.json();
                
                // Preserve current token selections
                preserveTokenSelections(params);
            } catch (error) {
                showError('Failed to load parameters: ' + error.message);
            }
        }
        
        // Helper function to preserve token selections across model changes
        function preserveTokenSelections(newParams) {
            const tokenSelects = ['input-tokens', 'output-tokens', 'random-tokens'];
            const paramKeys = ['input_tokens', 'output_tokens', 'random_tokens'];
            
            tokenSelects.forEach((selectId, index) => {
                const select = document.getElementById(selectId);
                const currentValue = select.value;
                const paramKey = paramKeys[index];
                
                // Update options
                populateSelect(selectId, newParams[paramKey]);
                
                // Try to restore the previous selection if it exists in new options
                if (currentValue && newParams[paramKey].includes(parseInt(currentValue))) {
                    select.value = currentValue;
                }
            });
        }
        

        
        // Utility function to populate select element
        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;
            
            // Clear existing options except the first one
            select.innerHTML = select.children[0].outerHTML;
            
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });
            
            // Restore selection if still valid
            const currentValueStr = currentValue.toString();
            const optionStrings = options.map(opt => opt.toString());
            if (optionStrings.includes(currentValueStr)) {
                select.value = currentValue;
            }
        }
        
        // Add current selection to comparison list
        function addToComparison() {
            if (!currentSelection) {
                showError('Please select a model from the tree first');
                return;
            }
            
            const inputTokens = document.getElementById('input-tokens').value;
            const outputTokens = document.getElementById('output-tokens').value;
            const randomTokens = document.getElementById('random-tokens').value;
            
            if (!inputTokens || !outputTokens || !randomTokens) {
                showError('Please select all token parameters before adding to comparison');
                return;
            }
            
            const combination = {
                runtime: currentSelection.runtime,
                instance_type: currentSelection.instance_type,
                model_name: currentSelection.model_name,
                input_tokens: parseInt(inputTokens),
                output_tokens: parseInt(outputTokens),
                random_tokens: parseInt(randomTokens)
            };
            
            // Check if combination already exists
            const exists = selectedCombinations.some(c => 
                c.runtime === combination.runtime &&
                c.instance_type === combination.instance_type &&
                c.model_name === combination.model_name &&
                c.input_tokens === combination.input_tokens &&
                c.output_tokens === combination.output_tokens &&
                c.random_tokens === combination.random_tokens
            );
            
            if (exists) {
                showError('This combination is already in the comparison list');
                return;
            }
            
            selectedCombinations.push(combination);
            updateComparisonList();
            
            // Auto-generate charts when combination is added
            generateCharts();
        }
        
        // Update the comparison list display
        function updateComparisonList() {
            const listContainer = document.getElementById('comparison-list');
            const itemsContainer = document.getElementById('comparison-items');
            
            if (selectedCombinations.length === 0) {
                listContainer.style.display = 'none';
                return;
            }
            
            listContainer.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            selectedCombinations.forEach((combo, index) => {
                const item = document.createElement('div');
                item.className = 'comparison-item';
                item.innerHTML = `
                    <span>${combo.runtime} - ${combo.instance_type} - ${combo.model_name} 
                    (in:${combo.input_tokens}, out:${combo.output_tokens}, rand:${combo.random_tokens})</span>
                    <button class="remove-btn" onclick="removeFromComparison(${index})">Remove</button>
                `;
                itemsContainer.appendChild(item);
            });
        }
        
        // Remove combination from comparison list
        function removeFromComparison(index) {
            selectedCombinations.splice(index, 1);
            updateComparisonList();
            
            // Auto-generate charts when combination is removed
            if (selectedCombinations.length > 0) {
                generateCharts();
            } else {
                clearCharts();
            }
        }
        
        // Clear all combinations
        function clearComparison() {
            selectedCombinations = [];
            updateComparisonList();
            clearCharts();
        }
        
        // Generate charts for selected combinations
        async function generateCharts() {
            if (selectedCombinations.length === 0) {
                clearCharts();
                return;
            }
            
            showLoading(true);
            clearError();
            
            try {
                const response = await fetch('/api/comparison-data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        combinations: selectedCombinations
                    })
                });
                
                const data = await response.json();
                createCharts(data);
            } catch (error) {
                showError('Failed to generate charts: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Create all charts
        function createCharts(data) {
            clearCharts();
            
            const container = document.getElementById('charts-container');
            
            // Create chart containers
            const chartTypes = [
                { id: 'first-token-latency', title: 'First Token Latency vs Concurrency', metric: 'first_token_latency_mean', unit: 'seconds' },
                { id: 'output-tokens-per-second', title: 'Output Tokens Per Second vs Concurrency', metric: 'output_tokens_per_second_mean', unit: 'tokens/sec' },
                { id: 'server-throughput', title: 'Server Throughput vs Concurrency', metric: 'server_throughput', unit: 'total tokens/sec' },
                { id: 'end-to-end-latency', title: 'End-to-End Latency vs Concurrency', metric: 'end_to_end_latency_mean', unit: 'seconds' },
                { id: 'requests-per-second', title: 'Request Rate vs Concurrency', metric: 'requests_per_second', unit: 'requests/sec' },
                { id: 'success-rate', title: 'Success Rate vs Concurrency', metric: 'success_rate', unit: '%' }
            ];
            
            chartTypes.forEach(chartType => {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `
                    <div class="chart-title">${chartType.title}</div>
                    <div class="chart-container">
                        <canvas id="${chartType.id}"></canvas>
                    </div>
                `;
                container.appendChild(wrapper);
                
                createChart(chartType.id, chartType.title, chartType.metric, chartType.unit, data);
            });
        }
        
        // Create individual chart
        function createChart(canvasId, title, metric, unit, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            const datasets = data.map((item, index) => {
                const combo = item.combination;
                const chartData = item.data.sort((a, b) => a.processes - b.processes);
                
                // Convert success rate to percentage for display
                const processedData = chartData.map(d => ({
                    x: d.processes,
                    y: metric === 'success_rate' ? d[metric] * 100 : d[metric]
                }));
                
                // Create a more readable label with full information
                const runtimeName = combo.runtime;
                
                // Extract instance size (4x, 48x)
                const instanceSize = combo.instance_type.includes('4xlarge') ? '4x' : 
                                   combo.instance_type.includes('48xlarge') ? '48x' : 
                                   combo.instance_type.split('.')[1] || combo.instance_type;
                const instanceBase = combo.instance_type.split('.')[0];
                const instanceInfo = `${instanceBase}.${instanceSize}`;
                
                // Keep full model name
                const modelName = combo.model_name;
                
                // Include all token information: inputâ†’output(rand)
                const tokenInfo = `${combo.input_tokens}â†’${combo.output_tokens}(${combo.random_tokens})`;
                
                const label = `${runtimeName}/${instanceInfo}/${modelName} ${tokenInfo}`;
                
                return {
                    label: label,
                    data: processedData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                };
            });
            
            charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 8,
                                font: {
                                    size: 9
                                },
                                boxWidth: 8,
                                maxWidth: 300
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Concurrent Processes'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${title.split(' vs ')[0]} (${unit})`
                            },
                            // Set Y-axis range for success rate chart
                            ...(metric === 'success_rate' && {
                                min: 0,
                                max: 100
                            })
                        }
                    }
                }
            });
        }
        
        // Clear all charts
        function clearCharts() {
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            charts = {};
            document.getElementById('charts-container').innerHTML = '';
        }
        
        // Show loading indicator
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        // Clear error message
        function clearError() {
            document.getElementById('error').style.display = 'none';
        }
        
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>