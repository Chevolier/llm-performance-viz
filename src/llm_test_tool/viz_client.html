<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCR XC Perf</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: white;
            border-right: 2px solid #eee;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .sidebar-header h2 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 1.4em;
            font-weight: bold;
        }

        .copyleft {
            font-size: 11px;
            color: #666;
            line-height: 1.3;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            text-align: center;
        }

        .copyleft a {
            color: #007bff;
            text-decoration: none;
        }

        .copyleft a:hover {
            text-decoration: underline;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }



        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        .control-group select,
        .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .slider-group label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .button-group {
            display: flex;
            gap: 8px;
            align-items: end;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
            flex: 1;
            min-width: 0;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        @media (max-width: 400px) {
            .btn {
                font-size: 10px;
                padding: 6px 8px;
                height: 28px;
            }
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-success:hover {
            background-color: #1e7e34;
        }



        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .chart-wrapper {
            background: white;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 420px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }



        /* Tree structure styles */
        .tree-container {
            margin-bottom: 20px;
        }

        .tree-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin: 0;
        }

        .tree-filter {
            position: relative;
            margin-bottom: 15px;
        }

        .filter-input {
            width: 100%;
            padding: 8px 30px 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        .filter-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .filter-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 16px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .filter-clear:hover {
            background: #f0f0f0;
            color: #333;
        }

        .filter-clear:hidden {
            display: none;
        }

        .tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .tree-node {
            margin: 0;
            padding: 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin: 2px 0;
            transition: background-color 0.2s;
        }

        .tree-item:hover {
            background-color: #f8f9fa;
        }

        .tree-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
        }

        .tree-item.expandable {
            font-weight: 600;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
        }

        .tree-toggle.expanded::before {
            content: '▼';
        }

        .tree-toggle.collapsed::before {
            content: '▶';
        }

        .tree-toggle.leaf::before {
            content: '';
        }

        .tree-toggle.leaf {
            width: 0;
            margin-right: 0;
        }

        .tree-children {
            list-style: none;
            padding-left: 16px;
            margin: 0;
            display: none;
        }

        .tree-children.expanded {
            display: block;
        }

        .tree-label {
            flex: 1;
            font-size: 13px;
        }

        .tree-checkbox {
            margin-left: 8px;
            margin-right: 8px;
            cursor: pointer;
            transform: scale(1.1);
        }

        .tree-checkbox:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .tree-count {
            font-size: 11px;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }

        .tree-node.filtered-hidden {
            display: none;
        }

        .tree-item.filter-match {
            background-color: #fff3cd;
        }

        .selected-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
        }

        .selected-info strong {
            color: #333;
        }

        .comparison-list {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }

        .comparison-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .comparison-item:last-child {
            border-bottom: none;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .tree-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .refresh-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }

        .refresh-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .refresh-btn:active {
            background: #dee2e6;
            transform: scale(0.95);
        }

        .refresh-btn.loading {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .refresh-icon {
            font-size: 16px;
            color: #495057;
            transition: transform 0.3s;
        }

        .refresh-btn.loading .refresh-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>GCR XC Perf</h2>
        </div>

        <div class="tree-container">
            <div class="tree-title">Token Configuration</div>
            <div class="slider-group">
                <label for="input-tokens">Input Tokens: <span id="input-tokens-value">1600</span></label>
                <input type="range" id="input-tokens" class="slider" min="100" max="4000" value="1600">
            </div>

            <div class="slider-group">
                <label for="output-tokens">Output Tokens: <span id="output-tokens-value">400</span></label>
                <input type="range" id="output-tokens" class="slider" min="50" max="2000" value="400">
            </div>

            <div class="slider-group">
                <label for="random-tokens">Random Tokens: <span id="random-tokens-value">1600</span></label>
                <input type="range" id="random-tokens" class="slider" min="100" max="4000" value="1600">
            </div>

            <div class="button-group" style="margin-top: 15px;">
                <button class="btn btn-primary" onclick="exportData()" title="Download raw data as JSON">
                    Export Data
                </button>
                <button class="btn btn-secondary" onclick="clearComparison()">Clear All</button>
                <button class="btn btn-success" onclick="copyShareableUrl()" title="Copy shareable URL to clipboard">
                    Share
                </button>
            </div>
        </div>

        <div class="tree-container">
            <div class="tree-header">
                <div class="tree-title">🚀 Runtime / Instance / Model</div>
                <button class="refresh-btn" id="refresh-tree" title="Refresh test results from disk">
                    <span class="refresh-icon">↻</span>
                </button>
            </div>
            <div class="tree-filter">
                <input type="text" id="tree-filter" class="filter-input" placeholder="Filter models..."
                    autocomplete="off">
                <button class="filter-clear" id="filter-clear" title="Clear filter">×</button>
            </div>
            <ul class="tree" id="runtime-tree">
                <!-- Tree structure will be populated here -->
            </ul>
        </div>

        <div id="selected-info" class="selected-info" style="display: none;">
            <strong>Selected:</strong><br>
            <span id="selected-text">None</span>
        </div>

        <div id="comparison-list" class="comparison-list" style="display: none;">
            <h3>Chart Combinations:</h3>
            <div id="comparison-items"></div>
        </div>



        <div class="copyleft">
            <a href="https://github.com/yytdfc/llm-performance-viz"
                target="_blank">https://github.com/yytdfc/llm-performance-viz</a>
        </div>
    </div>

    <div class="main-content">


        <div id="loading" class="loading" style="display: none;">
            Loading data...
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="charts-container" class="charts-container">
            <!-- Charts will be generated here -->
        </div>
    </div>

    <script>
        // Global variables
        let treeData = [];
        let selectedCombinations = [];
        let charts = {};
        let currentSelection = null;

        // Color palette for different combinations
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
        ];

        // Initialize the application
        async function init() {
            try {
                await loadTreeStructure();
                setupFilterEventListeners();
                
                // Initially disable sliders since no model is selected
                disableTokenSliders();
                
                // Set up initial slider event listeners
                setupSliderEventListeners();

                // Restore state from URL parameters after tree is loaded
                setTimeout(() => {
                    restoreStateFromUrl();
                }, 500);
            } catch (error) {
                showError('Failed to initialize application: ' + error.message);
            }
        }

        // Get API base path
        function getApiUrl(endpoint) {
            const basePath = window.API_BASE_PATH || '';
            return `${basePath}${endpoint}`;
        }

        // Load tree structure data
        async function loadTreeStructure() {
            const response = await fetch(getApiUrl('/api/tree-structure'));
            const data = await response.json();
            treeData = data.tree;
            renderTree();
        }



        // Refresh tree data from disk
        async function refreshTreeData() {
            const refreshBtn = document.getElementById('refresh-tree');
            const refreshIcon = refreshBtn.querySelector('.refresh-icon');

            try {
                // Show loading state
                refreshBtn.classList.add('loading');
                refreshBtn.disabled = true;

                // Clear current selection and comparisons
                currentSelection = null;
                selectedCombinations = [];
                updateSelectedInfo();
                updateComparisonList();
                clearCharts();
                
                // Reset sliders to default values and disable them
                disableTokenSliders();

                // Reload tree structure
                await loadTreeStructure();

                // Clear any active filter
                const filterInput = document.getElementById('tree-filter');
                if (filterInput.value) {
                    filterInput.value = '';
                    filterTree('');
                    document.getElementById('filter-clear').style.display = 'none';
                }

                // Reset all checkboxes
                document.querySelectorAll('.tree-checkbox').forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.disabled = false; // Keep enabled for one-click functionality
                });

                console.log('Tree data refreshed successfully');

            } catch (error) {
                showError('Failed to refresh tree data: ' + error.message);
            } finally {
                // Remove loading state
                refreshBtn.classList.remove('loading');
                refreshBtn.disabled = false;
            }
        }

        // Render the tree structure
        function renderTree() {
            const treeContainer = document.getElementById('runtime-tree');
            treeContainer.innerHTML = '';

            treeData.forEach(runtimeNode => {
                const runtimeElement = createTreeNode(runtimeNode, 0);
                treeContainer.appendChild(runtimeElement);
            });
        }

        // Create a tree node element
        function createTreeNode(node, level) {
            const li = document.createElement('li');
            li.className = 'tree-node';

            const item = document.createElement('div');
            item.className = 'tree-item';
            if (node.children && node.children.length > 0) {
                item.classList.add('expandable');
            }

            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (node.children && node.children.length > 0) {
                toggle.classList.add('expanded');
            } else {
                toggle.classList.add('leaf');
            }

            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = node.label;

            // Add checkbox for model nodes (leaf nodes)
            let checkbox = null;
            if (node.type === 'model') {
                checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'tree-checkbox';
                checkbox.disabled = false; // Enable by default for one-click functionality
                
                // Add checkbox event handler
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    handleModelCheckboxChange(node, checkbox.checked);
                });
            }

            const count = document.createElement('span');
            count.className = 'tree-count';
            count.textContent = node.count;

            item.appendChild(toggle);
            if (checkbox) {
                item.appendChild(checkbox);
            }
            item.appendChild(label);
            item.appendChild(count);

            // Store node data on the DOM element for reliable identification
            if (node.type === 'model') {
                item.dataset.nodeData = JSON.stringify({
                    runtime: node.runtime,
                    instance_type: node.instance_type,
                    model_name: node.model_name,
                    type: node.type,
                    label: node.label
                });
            }

            // Add click handler
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                // Don't handle tree item click if the click was on the checkbox
                if (e.target.classList.contains('tree-checkbox')) {
                    return;
                }
                handleTreeItemClick(node, item, toggle);
            });

            li.appendChild(item);

            // Add children if they exist
            if (node.children && node.children.length > 0) {
                const childrenContainer = document.createElement('ul');
                childrenContainer.className = 'tree-children expanded';

                node.children.forEach(child => {
                    const childElement = createTreeNode(child, level + 1);
                    childrenContainer.appendChild(childElement);
                });

                li.appendChild(childrenContainer);
            }

            return li;
        }

        // Handle tree item click
        async function handleTreeItemClick(node, itemElement, toggleElement) {
            // Handle expansion/collapse for parent nodes
            if (node.children && node.children.length > 0) {
                const childrenContainer = itemElement.parentElement.querySelector('.tree-children');
                const isExpanded = childrenContainer.classList.contains('expanded');

                if (isExpanded) {
                    childrenContainer.classList.remove('expanded');
                    toggleElement.classList.remove('expanded');
                    toggleElement.classList.add('collapsed');
                } else {
                    childrenContainer.classList.add('expanded');
                    toggleElement.classList.remove('collapsed');
                    toggleElement.classList.add('expanded');
                }
            }

            // Handle selection for model nodes (leaf nodes)
            if (node.type === 'model') {
                // Clear previous selection
                document.querySelectorAll('.tree-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });

                // Set new selection
                itemElement.classList.add('selected');
                currentSelection = {
                    runtime: node.runtime,
                    instance_type: node.instance_type,
                    model_name: node.model_name
                };

                // Update selected info display
                updateSelectedInfo();

                // Load token parameters for this selection (this will enable sliders)
                await loadTokenParameters();

                // Don't auto-check checkbox when clicking on model name
                // User must explicitly click the checkbox to select/deselect
            }
        }

        // Handle model checkbox change
        async function handleModelCheckboxChange(node, isChecked) {
            if (isChecked) {
                // Use default token values if sliders are disabled (not yet loaded)
                const inputTokensSlider = document.getElementById('input-tokens');
                const outputTokensSlider = document.getElementById('output-tokens');
                const randomTokensSlider = document.getElementById('random-tokens');

                let inputTokens, outputTokens, randomTokens;

                if (inputTokensSlider.disabled || outputTokensSlider.disabled || randomTokensSlider.disabled) {
                    // Use default values when token parameters haven't been loaded yet
                    inputTokens = 1600;
                    outputTokens = 400;
                    randomTokens = 1600;
                } else {
                    inputTokens = parseInt(inputTokensSlider.value);
                    outputTokens = parseInt(outputTokensSlider.value);
                    randomTokens = parseInt(randomTokensSlider.value);
                }

                const combination = {
                    runtime: node.runtime,
                    instance_type: node.instance_type,
                    model_name: node.model_name,
                    input_tokens: inputTokens,
                    output_tokens: outputTokens,
                    random_tokens: randomTokens
                };

                // Check if combination already exists
                const exists = selectedCombinations.some(c =>
                    c.runtime === combination.runtime &&
                    c.instance_type === combination.instance_type &&
                    c.model_name === combination.model_name &&
                    c.input_tokens === combination.input_tokens &&
                    c.output_tokens === combination.output_tokens &&
                    c.random_tokens === combination.random_tokens
                );

                if (!exists) {
                    selectedCombinations.push(combination);
                    updateComparisonList();
                    generateCharts();
                    updateUrlWithState();
                }
            } else {
                // Remove from comparison
                const modelKey = `${node.runtime}-${node.instance_type}-${node.model_name}`;
                selectedCombinations = selectedCombinations.filter(c => 
                    `${c.runtime}-${c.instance_type}-${c.model_name}` !== modelKey
                );
                updateComparisonList();
                
                if (selectedCombinations.length > 0) {
                    generateCharts();
                } else {
                    clearCharts();
                }
                updateUrlWithState();
            }
        }

        // Update the selected info display
        function updateSelectedInfo() {
            const selectedInfo = document.getElementById('selected-info');
            const selectedText = document.getElementById('selected-text');

            if (currentSelection) {
                selectedText.innerHTML = `
                    <strong>Runtime:</strong> ${currentSelection.runtime}<br>
                    <strong>Instance:</strong> ${currentSelection.instance_type}<br>
                    <strong>Model:</strong> ${currentSelection.model_name}
                `;
                selectedInfo.style.display = 'block';
            } else {
                selectedInfo.style.display = 'none';
            }
        }

        // Load token parameters for the current selection
        async function loadTokenParameters() {
            if (!currentSelection) return;

            try {
                const response = await fetch(getApiUrl(`/api/parameters?runtime=${encodeURIComponent(currentSelection.runtime)}&instance_type=${encodeURIComponent(currentSelection.instance_type)}&model_name=${encodeURIComponent(currentSelection.model_name)}`));
                const params = await response.json();

                console.log('Loaded parameters:', params); // Debug log

                // Preserve current token selections
                preserveTokenSelections(params);

                // Update checkbox state based on current combinations
                updateModelCheckboxStates();
            } catch (error) {
                console.error('Failed to load parameters:', error); // Debug log
                showError('Failed to load parameters: ' + error.message);
                
                // Enable sliders with default ranges if API fails
                enableSlidersWithDefaults();
            }
        }

        // Enable sliders with default ranges when API fails
        function enableSlidersWithDefaults() {
            const sliders = [
                { id: 'input-tokens', min: 100, max: 4000, default: 1600 },
                { id: 'output-tokens', min: 50, max: 2000, default: 400 },
                { id: 'random-tokens', min: 100, max: 4000, default: 1600 }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.id + '-value');
                
                sliderElement.disabled = false;
                sliderElement.min = slider.min;
                sliderElement.max = slider.max;
                sliderElement.value = slider.default;
                valueElement.textContent = slider.default;
                
                // Set available values to allow any value in range
                sliderElement.availableValues = [];
                for (let i = slider.min; i <= slider.max; i += 100) {
                    sliderElement.availableValues.push(i);
                }
            });

            setupSliderEventListeners();
            updateRandomTokensMax();
        }

        // Update checkbox states based on current combinations
        function updateModelCheckboxStates() {
            document.querySelectorAll('.tree-checkbox').forEach(checkbox => {
                const treeItem = checkbox.closest('.tree-item');
                const treeNode = findNodeFromTreeItem(treeItem);
                
                if (treeNode && treeNode.type === 'model') {
                    const modelKey = `${treeNode.runtime}-${treeNode.instance_type}-${treeNode.model_name}`;
                    const isInComparison = selectedCombinations.some(c => 
                        `${c.runtime}-${c.instance_type}-${c.model_name}` === modelKey
                    );
                    checkbox.checked = isInComparison;
                }
            });
        }

        // Helper function to find node data from tree item element
        function findNodeFromTreeItem(treeItem) {
            // Use stored node data for reliable identification
            const nodeDataStr = treeItem.dataset.nodeData;
            if (nodeDataStr) {
                try {
                    return JSON.parse(nodeDataStr);
                } catch (e) {
                    console.warn('Failed to parse node data:', e);
                }
            }
            
            // Fallback to the old method if no data attribute found
            const label = treeItem.querySelector('.tree-label').textContent;
            
            // Search through tree data to find matching node
            function searchTree(nodes) {
                for (const node of nodes) {
                    if (node.label === label && node.type === 'model') {
                        return node;
                    }
                    if (node.children) {
                        const found = searchTree(node.children);
                        if (found) return found;
                    }
                }
                return null;
            }
            
            return searchTree(treeData);
        }

        // Update combinations for checked models when token values change
        function updateCheckedModelCombinations() {
            if (!currentSelection) return;

            const inputTokens = parseInt(document.getElementById('input-tokens').value);
            const outputTokens = parseInt(document.getElementById('output-tokens').value);
            const randomTokens = parseInt(document.getElementById('random-tokens').value);

            // Find the checkbox for the current selection
            const currentModelCheckbox = document.querySelector('.tree-item.selected .tree-checkbox');
            const currentModelKey = `${currentSelection.runtime}-${currentSelection.instance_type}-${currentSelection.model_name}`;

            // Check if this exact token configuration already exists in the chart
            const exactConfigExists = selectedCombinations.some(c =>
                c.runtime === currentSelection.runtime &&
                c.instance_type === currentSelection.instance_type &&
                c.model_name === currentSelection.model_name &&
                c.input_tokens === inputTokens &&
                c.output_tokens === outputTokens &&
                c.random_tokens === randomTokens
            );

            // Update checkbox state based on whether this configuration exists
            if (currentModelCheckbox) {
                currentModelCheckbox.checked = exactConfigExists;
            }

            // Don't automatically add/remove combinations when sliding
            // User must explicitly check/uncheck the checkbox to add/remove
        }

        // Helper function to preserve token selections across model changes
        function preserveTokenSelections(newParams) {
            const sliders = [
                { id: 'input-tokens', key: 'input_tokens', valueId: 'input-tokens-value' },
                { id: 'output-tokens', key: 'output_tokens', valueId: 'output-tokens-value' },
                { id: 'random-tokens', key: 'random_tokens', valueId: 'random-tokens-value' }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                const values = newParams[slider.key];

                if (values && values.length > 0) {
                    const minVal = Math.min(...values);
                    const maxVal = Math.max(...values);

                    // Enable slider and set range
                    sliderElement.disabled = false;
                    sliderElement.min = minVal;
                    sliderElement.max = maxVal;

                    // Try to preserve current value if it's within range
                    const currentValue = parseInt(sliderElement.value);
                    if (currentValue >= minVal && currentValue <= maxVal && values.includes(currentValue)) {
                        sliderElement.value = currentValue;
                    } else {
                        // Set to preferred default values if available, otherwise first available value
                        let defaultValue;
                        if (slider.id === 'input-tokens') {
                            defaultValue = values.includes(1600) ? 1600 : values[0];
                        } else if (slider.id === 'output-tokens') {
                            defaultValue = values.includes(400) ? 400 : values[0];
                        } else if (slider.id === 'random-tokens') {
                            defaultValue = values.includes(1600) ? 1600 : values[0];
                        } else {
                            defaultValue = values[0];
                        }
                        sliderElement.value = defaultValue;
                    }

                    // Update display value
                    valueElement.textContent = sliderElement.value;

                    // Store available values for validation
                    sliderElement.availableValues = values;

                    // Store original values for random tokens constraint logic
                    if (slider.id === 'random-tokens') {
                        sliderElement.originalAvailableValues = [...values];
                    }
                } else {
                    // Disable slider if no values available
                    sliderElement.disabled = true;
                    sliderElement.value = 0;
                    valueElement.textContent = '-';
                    sliderElement.availableValues = [];
                }
            });

            // Set up event listeners for sliders
            setupSliderEventListeners();

            // Update random tokens max based on current input tokens
            updateRandomTokensMax();
        }

        // Setup event listeners for sliders
        function setupSliderEventListeners() {
            const inputTokensSlider = document.getElementById('input-tokens');
            const outputTokensSlider = document.getElementById('output-tokens');
            const randomTokensSlider = document.getElementById('random-tokens');

            // Remove existing event listeners to avoid duplicates
            inputTokensSlider.oninput = null;
            outputTokensSlider.oninput = null;
            randomTokensSlider.oninput = null;

            // Input tokens slider
            inputTokensSlider.addEventListener('input', function () {
                if (this.disabled) return; // Don't process if slider is disabled
                let value = parseInt(this.value);
                if (this.availableValues && this.availableValues.length > 0) {
                    value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                }
                document.getElementById('input-tokens-value').textContent = value;
                updateRandomTokensMax();
                updateCheckedModelCombinations();
            });

            // Output tokens slider
            outputTokensSlider.addEventListener('input', function () {
                if (this.disabled) return; // Don't process if slider is disabled
                let value = parseInt(this.value);
                if (this.availableValues && this.availableValues.length > 0) {
                    value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                }
                document.getElementById('output-tokens-value').textContent = value;
                updateCheckedModelCombinations();
            });

            // Random tokens slider
            randomTokensSlider.addEventListener('input', function () {
                if (this.disabled) return; // Don't process if slider is disabled
                let value = parseInt(this.value);
                if (this.availableValues && this.availableValues.length > 0) {
                    value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                }
                document.getElementById('random-tokens-value').textContent = value;
                updateCheckedModelCombinations();
            });
        }

        // Find closest available value from the allowed values
        function findClosestAvailableValue(targetValue, availableValues) {
            if (!availableValues || availableValues.length === 0) return targetValue;

            const target = parseInt(targetValue);
            return availableValues.reduce((prev, curr) => {
                return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;
            });
        }

        // Disable token sliders when no model is selected
        function disableTokenSliders() {
            const sliders = [
                { id: 'input-tokens', valueId: 'input-tokens-value', defaultValue: 1600 },
                { id: 'output-tokens', valueId: 'output-tokens-value', defaultValue: 400 },
                { id: 'random-tokens', valueId: 'random-tokens-value', defaultValue: 1600 }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                sliderElement.disabled = true;
                sliderElement.value = slider.defaultValue;
                valueElement.textContent = slider.defaultValue;
            });
        }

        // Update random tokens max value based on input tokens
        function updateRandomTokensMax() {
            const inputTokensSlider = document.getElementById('input-tokens');
            const randomTokensSlider = document.getElementById('random-tokens');
            const randomTokensValue = document.getElementById('random-tokens-value');

            if (!inputTokensSlider.disabled && !randomTokensSlider.disabled) {
                const inputTokensValue = parseInt(inputTokensSlider.value);

                // Get original available values (stored when model was selected)
                const originalAvailableValues = randomTokensSlider.originalAvailableValues || randomTokensSlider.availableValues || [];

                // Filter available values to be <= input tokens
                const filteredValues = originalAvailableValues.filter(val => val <= inputTokensValue);

                if (filteredValues.length > 0) {
                    const newMin = Math.min(...filteredValues);
                    const newMax = Math.max(...filteredValues);

                    // Update slider range
                    randomTokensSlider.min = newMin;
                    randomTokensSlider.max = newMax;
                    randomTokensSlider.disabled = false;

                    // Update available values for this constraint
                    randomTokensSlider.availableValues = filteredValues;

                    // Adjust current value if it needs to be clipped or is invalid
                    const currentValue = parseInt(randomTokensSlider.value);
                    let needsAdjustment = false;
                    let newValue = currentValue;

                    // Check if current value exceeds input tokens constraint
                    if (currentValue > inputTokensValue) {
                        // Clip to the largest available value that's <= input tokens
                        newValue = Math.max(...filteredValues);
                        needsAdjustment = true;
                    }
                    // Check if current value is outside the valid range
                    else if (currentValue > newMax || currentValue < newMin) {
                        newValue = Math.min(Math.max(currentValue, newMin), newMax);
                        needsAdjustment = true;
                    }
                    // Check if current value is not in the available values list
                    else if (!filteredValues.includes(currentValue)) {
                        newValue = findClosestAvailableValue(currentValue, filteredValues);
                        needsAdjustment = true;
                    }

                    if (needsAdjustment) {
                        randomTokensSlider.value = newValue;
                        randomTokensValue.textContent = newValue;
                    }
                } else {
                    // No valid values, disable random tokens
                    randomTokensSlider.disabled = true;
                    randomTokensValue.textContent = '-';
                }
            }
        }



        // Utility function to populate select element
        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // Clear existing options except the first one
            select.innerHTML = select.children[0].outerHTML;

            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });

            // Restore selection if still valid
            const currentValueStr = currentValue.toString();
            const optionStrings = options.map(opt => opt.toString());
            if (optionStrings.includes(currentValueStr)) {
                select.value = currentValue;
            }
        }

        // Export current chart data as CSV
        function exportData() {
            if (selectedCombinations.length === 0) {
                showError('No data to export. Please select some models first.');
                return;
            }

            // Use the same data that's currently displayed in charts
            if (!window.currentChartData) {
                showError('No chart data available. Please wait for charts to load.');
                return;
            }

            const csvContent = generateCSV(window.currentChartData);

            // Create and download the CSV file
            const dataBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            const now = new Date();
            const timestamp = now.toISOString().replace(/[:.]/g, '-').replace('T', '_').split('.')[0];
            link.download = `llm-performance-data-${timestamp}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showSuccess('Data exported successfully!');
        }

        // Helper function to escape CSV values
        function escapeCSVValue(value) {
            if (value === null || value === undefined || value === '') {
                return '';
            }
            // Convert to string and check if it needs escaping
            const str = String(value);
            if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                // Escape quotes by doubling them and wrap in quotes
                return '"' + str.replace(/"/g, '""') + '"';
            }
            return str;
        }

        // Generate CSV content from chart data
        function generateCSV(data) {
            const metrics = [
                { key: 'first_token_latency_mean', title: 'First Token Latency (seconds)' },
                { key: 'output_tokens_per_second_mean', title: 'Output Tokens Per Second' },
                { key: 'server_throughput', title: 'Server Throughput (total tokens/sec)' },
                { key: 'end_to_end_latency_mean', title: 'End-to-End Latency (seconds)' },
                { key: 'requests_per_second', title: 'Request Rate (requests/sec)' },
                { key: 'success_rate', title: 'Success Rate (%)' },
                { key: 'cost_per_million_tokens', title: 'Cost per Million Tokens ($)' },
                { key: 'cost_per_1k_requests', title: 'Cost per 1k Requests ($)' }
            ];

            let csvContent = `Export Date: ${new Date().toISOString()}\n\n`;

            // Get all unique concurrency levels across all models
            const allConcurrencyLevels = new Set();
            data.forEach(item => {
                item.data.forEach(d => allConcurrencyLevels.add(d.processes));
            });
            const sortedConcurrencyLevels = Array.from(allConcurrencyLevels).sort((a, b) => a - b);

            // Create model labels
            const modelLabels = data.map(item => {
                const combo = item.combination;
                const runtimeName = combo.runtime;
                const instanceSize = combo.instance_type.includes('4xlarge') ? '4x' :
                    combo.instance_type.includes('48xlarge') ? '48x' :
                        combo.instance_type.split('.')[1] || combo.instance_type;
                const instanceBase = combo.instance_type.split('.')[0];
                const instanceInfo = `${instanceBase}.${instanceSize}`;
                const modelName = combo.model_name;
                const tokenInfo = `${combo.input_tokens}(${combo.random_tokens})->${combo.output_tokens}`;
                return `${runtimeName}/${instanceInfo}/${modelName} ${tokenInfo}`;
            });

            // Generate CSV for each metric
            metrics.forEach((metric, metricIndex) => {
                if (metricIndex > 0) csvContent += '\n';
                
                csvContent += `${metric.title}\n`;
                
                // Header row: Concurrency, Model1, Model2, ...
                const headerRow = ['Concurrency', ...modelLabels.map(escapeCSVValue)];
                csvContent += headerRow.join(',') + '\n';

                // Data rows
                sortedConcurrencyLevels.forEach(concurrency => {
                    const row = [concurrency];
                    
                    data.forEach(item => {
                        const dataPoint = item.data.find(d => d.processes === concurrency);
                        if (dataPoint && dataPoint[metric.key] !== undefined) {
                            let value = dataPoint[metric.key];
                            // Convert success rate to percentage for display
                            if (metric.key === 'success_rate') {
                                value = value * 100;
                            }
                            // Keep raw numeric values without quotes
                            row.push(typeof value === 'number' ? value : parseFloat(value) || '');
                        } else {
                            row.push(''); // Empty cell if no data
                        }
                    });
                    
                    // Join row with proper escaping - only escape non-numeric values
                    const escapedRow = row.map((val, index) => {
                        if (index === 0 || val === '' || typeof val === 'number') {
                            return val; // Don't escape concurrency numbers or empty values or numeric values
                        }
                        return escapeCSVValue(val);
                    });
                    csvContent += escapedRow.join(',') + '\n';
                });
                
                csvContent += '\n'; // Extra line between metric blocks
            });

            return csvContent;
        }

        // Update the comparison list display
        function updateComparisonList() {
            const listContainer = document.getElementById('comparison-list');
            const itemsContainer = document.getElementById('comparison-items');

            if (selectedCombinations.length === 0) {
                listContainer.style.display = 'none';
                return;
            }

            listContainer.style.display = 'block';
            itemsContainer.innerHTML = '';

            selectedCombinations.forEach((combo, index) => {
                const item = document.createElement('div');
                item.className = 'comparison-item';
                item.innerHTML = `
                    <span>${combo.runtime} - ${combo.instance_type} - ${combo.model_name} 
                    (in:${combo.input_tokens}, out:${combo.output_tokens}, rand:${combo.random_tokens})</span>
                    <button class="remove-btn" onclick="removeFromComparison(${index})">Remove</button>
                `;
                itemsContainer.appendChild(item);
            });
        }

        // Remove combination from comparison list
        function removeFromComparison(index) {
            const removedCombo = selectedCombinations[index];
            selectedCombinations.splice(index, 1);
            updateComparisonList();

            // Update corresponding checkbox
            const modelKey = `${removedCombo.runtime}-${removedCombo.instance_type}-${removedCombo.model_name}`;
            document.querySelectorAll('.tree-checkbox').forEach(checkbox => {
                const treeItem = checkbox.closest('.tree-item');
                const treeNode = findNodeFromTreeItem(treeItem);
                
                if (treeNode && `${treeNode.runtime}-${treeNode.instance_type}-${treeNode.model_name}` === modelKey) {
                    checkbox.checked = false;
                }
            });

            // Auto-generate charts when combination is removed
            if (selectedCombinations.length > 0) {
                generateCharts();
            } else {
                clearCharts();
            }

            // Update URL with new state
            updateUrlWithState();
        }

        // Clear all combinations
        function clearComparison() {
            selectedCombinations = [];
            updateComparisonList();
            clearCharts();

            // Uncheck all checkboxes
            document.querySelectorAll('.tree-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Clear current selection and reset sliders to default values
            currentSelection = null;
            updateSelectedInfo();
            disableTokenSliders();

            // Update URL with new state
            updateUrlWithState();
        }

        // Generate charts for selected combinations
        async function generateCharts() {
            if (selectedCombinations.length === 0) {
                clearCharts();
                return;
            }

            showLoading(true);
            clearError();

            try {
                const response = await fetch(getApiUrl('/api/comparison-data'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        combinations: selectedCombinations
                    })
                });

                const data = await response.json();
                createCharts(data);
            } catch (error) {
                showError('Failed to generate charts: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Create all charts
        function createCharts(data) {
            clearCharts();

            // Store chart data globally for export functionality
            window.currentChartData = data;

            const container = document.getElementById('charts-container');

            // Create chart containers
            const chartTypes = [
                { id: 'first-token-latency', title: 'First Token Latency vs Concurrency', metric: 'first_token_latency_mean', unit: 'seconds' },
                { id: 'output-tokens-per-second', title: 'Output Tokens Per Second vs Concurrency', metric: 'output_tokens_per_second_mean', unit: 'tokens/sec' },
                { id: 'server-throughput', title: 'Server Throughput vs Concurrency', metric: 'server_throughput', unit: 'total tokens/sec' },
                { id: 'end-to-end-latency', title: 'End-to-End Latency vs Concurrency', metric: 'end_to_end_latency_mean', unit: 'seconds' },
                { id: 'requests-per-second', title: 'Request Rate vs Concurrency', metric: 'requests_per_second', unit: 'requests/sec' },
                { id: 'success-rate', title: 'Success Rate vs Concurrency', metric: 'success_rate', unit: '%' },
                { id: 'cost-per-million-tokens', title: 'Cost per Million Tokens vs Concurrency', metric: 'cost_per_million_tokens', unit: '$' },
                { id: 'cost-per-1k-requests', title: 'Cost per 1k Requests vs Concurrency', metric: 'cost_per_1k_requests', unit: '$' }
            ];

            chartTypes.forEach(chartType => {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `
                    <div class="chart-title">${chartType.title}</div>
                    <div class="chart-container">
                        <canvas id="${chartType.id}"></canvas>
                    </div>
                `;
                container.appendChild(wrapper);

                createChart(chartType.id, chartType.title, chartType.metric, chartType.unit, data);
            });
        }

        // Create individual chart
        function createChart(canvasId, title, metric, unit, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            const datasets = data.map((item, index) => {
                const combo = item.combination;
                const chartData = item.data.sort((a, b) => a.processes - b.processes);

                // Convert success rate to percentage for display
                const processedData = chartData.map(d => ({
                    x: d.processes,
                    y: metric === 'success_rate' ? d[metric] * 100 : d[metric]
                }));

                // Create a more readable label with full information
                const runtimeName = combo.runtime;

                // Extract instance size (4x, 48x)
                const instanceSize = combo.instance_type.includes('4xlarge') ? '4x' :
                    combo.instance_type.includes('48xlarge') ? '48x' :
                        combo.instance_type.split('.')[1] || combo.instance_type;
                const instanceBase = combo.instance_type.split('.')[0];
                const instanceInfo = `${instanceBase}.${instanceSize}`;

                // Keep full model name
                const modelName = combo.model_name;

                // Include all token information: input(rand)->output
                const tokenInfo = `${combo.input_tokens}(${combo.random_tokens})->${combo.output_tokens}`;

                const label = `${runtimeName}/${instanceInfo}/${modelName} ${tokenInfo}`;

                return {
                    label: label,
                    data: processedData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                };
            });

            charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 8,
                                font: {
                                    size: 9
                                },
                                boxWidth: 8,
                                maxWidth: 300
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Concurrent Processes'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${title.split(' vs ')[0]} (${unit})`
                            },
                            // Set Y-axis range for success rate chart
                            ...(metric === 'success_rate' && {
                                min: 0,
                                max: 100
                            })
                        }
                    }
                }
            });
        }

        // Clear all charts
        function clearCharts() {
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            charts = {};
            document.getElementById('charts-container').innerHTML = '';
            
            // Clear stored chart data
            window.currentChartData = null;
        }

        // Show loading indicator
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Clear error message
        function clearError() {
            document.getElementById('error').style.display = 'none';
        }

        // Setup filter event listeners
        function setupFilterEventListeners() {
            const filterInput = document.getElementById('tree-filter');
            const filterClear = document.getElementById('filter-clear');
            const refreshBtn = document.getElementById('refresh-tree');

            // Filter input event
            if (filterInput) {
                filterInput.addEventListener('input', function () {
                    const filterText = this.value.trim();
                    filterTree(filterText);

                    // Show/hide clear button
                    if (filterText && filterClear) {
                        filterClear.style.display = 'flex';
                    } else if (filterClear) {
                        filterClear.style.display = 'none';
                    }

                    // Update URL with filter state
                    updateUrlWithState();
                });
            }

            // Clear button event
            if (filterClear) {
                filterClear.addEventListener('click', function () {
                    if (filterInput) {
                        filterInput.value = '';
                        filterTree('');
                        filterInput.focus();
                    }
                    this.style.display = 'none';

                    // Update URL with cleared filter
                    updateUrlWithState();
                });
            }

            // Refresh button event
            if (refreshBtn) {
                refreshBtn.addEventListener('click', async function () {
                    await refreshTreeData();
                });
            }

            // Instance price change event (if element exists)
            const instancePriceInput = document.getElementById('instance-price');
            if (instancePriceInput) {
                instancePriceInput.addEventListener('input', function () {
                    // Regenerate charts when price changes
                    if (selectedCombinations.length > 0) {
                        generateCharts();
                    }

                    // Update URL with pricing info
                    updateUrlWithState();
                });
            }

            // Initially hide clear button
            if (filterClear) {
                filterClear.style.display = 'none';
            }
        }

        // Filter tree based on search text
        function filterTree(filterText) {
            const tree = document.getElementById('runtime-tree');
            const allNodes = tree.querySelectorAll('.tree-node');

            if (!filterText) {
                // Show all nodes and remove highlights
                allNodes.forEach(node => {
                    node.classList.remove('filtered-hidden');
                    const item = node.querySelector('.tree-item');
                    if (item) {
                        item.classList.remove('filter-match');
                    }
                });
                return;
            }

            const searchText = filterText.toLowerCase();

            // First pass: mark matching nodes
            const matchingNodes = new Set();
            allNodes.forEach(node => {
                const item = node.querySelector('.tree-item');
                const label = item.querySelector('.tree-label');

                if (label && label.textContent.toLowerCase().includes(searchText)) {
                    matchingNodes.add(node);
                    item.classList.add('filter-match');

                    // Mark all parent nodes as matching
                    let parent = node.parentElement;
                    while (parent && parent.classList.contains('tree-children')) {
                        const parentNode = parent.parentElement;
                        if (parentNode && parentNode.classList.contains('tree-node')) {
                            matchingNodes.add(parentNode);
                            parent = parentNode.parentElement;
                        } else {
                            break;
                        }
                    }

                    // Mark all child nodes as matching
                    const childNodes = node.querySelectorAll('.tree-node');
                    childNodes.forEach(child => matchingNodes.add(child));
                } else {
                    item.classList.remove('filter-match');
                }
            });

            // Second pass: show/hide nodes based on matches
            allNodes.forEach(node => {
                if (matchingNodes.has(node)) {
                    node.classList.remove('filtered-hidden');

                    // Auto-expand parent nodes that contain matches
                    const childrenContainer = node.querySelector('.tree-children');
                    const toggle = node.querySelector('.tree-toggle');
                    if (childrenContainer && toggle && !toggle.classList.contains('leaf')) {
                        childrenContainer.classList.add('expanded');
                        toggle.classList.remove('collapsed');
                        toggle.classList.add('expanded');
                    }
                } else {
                    node.classList.add('filtered-hidden');
                }
            });
        }

        // URL State Management
        function updateUrlWithState() {
            const url = new URL(window.location);

            // Clear existing parameters
            url.searchParams.delete('combinations');
            url.searchParams.delete('filter');

            // Add current combinations
            if (selectedCombinations.length > 0) {
                const combinationsData = selectedCombinations.map(combo => ({
                    r: combo.runtime,
                    i: combo.instance_type,
                    m: combo.model_name,
                    it: combo.input_tokens,
                    ot: combo.output_tokens,
                    rt: combo.random_tokens
                }));
                url.searchParams.set('combinations', btoa(JSON.stringify(combinationsData)));
            }

            // Add current filter
            const filterInput = document.getElementById('tree-filter');
            if (filterInput && filterInput.value.trim()) {
                url.searchParams.set('filter', filterInput.value.trim());
            }



            // Update URL without page reload
            window.history.replaceState({}, '', url);
        }

        function restoreStateFromUrl() {
            const url = new URL(window.location);

            // Restore filter
            const filter = url.searchParams.get('filter');
            if (filter) {
                const filterInput = document.getElementById('tree-filter');
                const filterClear = document.getElementById('filter-clear');
                if (filterInput) {
                    filterInput.value = filter;
                    filterTree(filter);
                    if (filterClear) {
                        filterClear.style.display = 'flex';
                    }
                }
            }

            // Restore instance price
            const price = url.searchParams.get('price');
            if (price) {
                const instancePriceInput = document.getElementById('instance-price');
                if (instancePriceInput) {
                    instancePriceInput.value = price;
                }
            }

            // Restore combinations
            const combinationsParam = url.searchParams.get('combinations');
            if (combinationsParam) {
                try {
                    const combinationsData = JSON.parse(atob(combinationsParam));

                    // Convert back to full format
                    const combinations = combinationsData.map(combo => ({
                        runtime: combo.r,
                        instance_type: combo.i,
                        model_name: combo.m,
                        input_tokens: combo.it,
                        output_tokens: combo.ot,
                        random_tokens: combo.rt
                    }));

                    selectedCombinations = combinations;
                    updateComparisonList();

                    // Generate charts if combinations exist
                    if (selectedCombinations.length > 0) {
                        generateCharts();
                    }

                    // Update checkbox states after restoring combinations
                    setTimeout(() => {
                        updateModelCheckboxStates();
                    }, 100);
                } catch (error) {
                    console.warn('Failed to restore combinations from URL:', error);
                }
            }
        }

        function copyShareableUrl() {
            updateUrlWithState();
            const url = window.location.href;

            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(url).then(() => {
                    showSuccess('Shareable URL copied to clipboard!');
                }).catch(() => {
                    fallbackCopyUrl(url);
                });
            } else {
                fallbackCopyUrl(url);
            }
        }

        function fallbackCopyUrl(url) {
            // Fallback for older browsers or non-HTTPS
            const textArea = document.createElement('textarea');
            textArea.value = url;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
                showSuccess('Shareable URL copied to clipboard!');
            } catch (err) {
                showError('Failed to copy URL. Please copy manually: ' + url);
            }

            document.body.removeChild(textArea);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #d4edda;
                color: #155724;
                padding: 15px;
                border-radius: 4px;
                border: 1px solid #c3e6cb;
                z-index: 1000;
                max-width: 300px;
            `;
            successDiv.textContent = message;
            document.body.appendChild(successDiv);

            setTimeout(() => {
                document.body.removeChild(successDiv);
            }, 3000);
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>