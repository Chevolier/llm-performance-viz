<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Performance Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #eee;
        }
        
        .header h1 {
            color: #333;
            margin: 0;
            font-size: 2.5em;
        }
        
        .header p {
            color: #666;
            margin: 10px 0 0 0;
            font-size: 1.1em;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .control-group select, .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .control-group select:focus, .control-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            align-items: end;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0056b3;
        }
        
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #545b62;
        }
        
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #1e7e34;
        }
        
        .comparison-list {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }
        
        .comparison-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }
        
        .comparison-item:last-child {
            border-bottom: none;
        }
        
        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .remove-btn:hover {
            background: #c82333;
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .chart-wrapper {
            background: white;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart-container {
            position: relative;
            height: 420px;
        }
        
        /* Custom legend styling */
        .chart-wrapper canvas {
            max-width: 100%;
        }
        
        .chart-wrapper .chartjs-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .chart-wrapper .chartjs-legend li {
            margin: 2px 8px;
            font-size: 11px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }
        
        .stats-panel {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #1976d2;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸš€ LLM Performance Visualization</h1>
            <p>Interactive analysis of LLM inference performance across different configurations</p>
        </div>
        
        <div id="stats-panel" class="stats-panel" style="display: none;">
            <div class="stats-grid" id="stats-content">
                <!-- Stats will be populated here -->
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="runtime-select">Runtime:</label>
                <select id="runtime-select">
                    <option value="">Select Runtime...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="instance-select">Instance Type:</label>
                <select id="instance-select">
                    <option value="">Select Instance...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="model-select">Model:</label>
                <select id="model-select">
                    <option value="">Select Model...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="input-tokens">Input Tokens:</label>
                <select id="input-tokens">
                    <option value="">Select Input Tokens...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="output-tokens">Output Tokens:</label>
                <select id="output-tokens">
                    <option value="">Select Output Tokens...</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="random-tokens">Random Tokens:</label>
                <select id="random-tokens">
                    <option value="">Select Random Tokens...</option>
                </select>
            </div>
            
            <div class="button-group">
                <button class="btn btn-primary" onclick="addToComparison()">Add to Comparison</button>
                <button class="btn btn-secondary" onclick="clearComparison()">Clear All</button>
            </div>
        </div>
        
        <div id="comparison-list" class="comparison-list" style="display: none;">
            <h3>Selected Combinations for Comparison:</h3>
            <div id="comparison-items"></div>
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            Loading data...
        </div>
        
        <div id="error" class="error" style="display: none;"></div>
        
        <div id="charts-container" class="charts-container">
            <!-- Charts will be generated here -->
        </div>
    </div>

    <script>
        // Global variables
        let combinations = [];
        let selectedCombinations = [];
        let charts = {};
        
        // Color palette for different combinations
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
        ];
        
        // Initialize the application
        async function init() {
            try {
                await loadCombinations();
                await loadStats();
                setupEventListeners();
            } catch (error) {
                showError('Failed to initialize application: ' + error.message);
            }
        }
        
        // Load available combinations
        async function loadCombinations() {
            const response = await fetch('/api/combinations');
            combinations = await response.json();
            
            // Populate runtime dropdown
            const runtimes = [...new Set(combinations.map(c => c.runtime))];
            populateSelect('runtime-select', runtimes);
        }
        
        // Load overall statistics
        async function loadStats() {
            try {
                const response = await fetch('/api/stats');
                const stats = await response.json();
                
                if (stats.error) {
                    console.warn('No stats available:', stats.error);
                    return;
                }
                
                const statsPanel = document.getElementById('stats-panel');
                const statsContent = document.getElementById('stats-content');
                
                statsContent.innerHTML = `
                    <div class="stat-item">
                        <div class="stat-value">${stats.total_tests}</div>
                        <div class="stat-label">Total Tests</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.unique_combinations}</div>
                        <div class="stat-label">Combinations</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.performance_summary.avg_first_token_latency.toFixed(3)}s</div>
                        <div class="stat-label">Avg First Token Latency</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.performance_summary.avg_throughput.toFixed(1)}</div>
                        <div class="stat-label">Avg Output Tokens/Sec</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${stats.performance_summary.avg_server_throughput ? stats.performance_summary.avg_server_throughput.toFixed(1) : 'N/A'}</div>
                        <div class="stat-label">Avg Server Throughput</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${(stats.performance_summary.avg_success_rate * 100).toFixed(1)}%</div>
                        <div class="stat-label">Avg Success Rate</div>
                    </div>
                `;
                
                statsPanel.style.display = 'block';
            } catch (error) {
                console.warn('Failed to load stats:', error);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('runtime-select').addEventListener('change', onRuntimeChange);
            document.getElementById('instance-select').addEventListener('change', onInstanceChange);
            document.getElementById('model-select').addEventListener('change', onModelChange);
        }
        
        // Handle runtime selection change
        function onRuntimeChange() {
            const runtime = document.getElementById('runtime-select').value;
            const instances = [...new Set(combinations
                .filter(c => c.runtime === runtime)
                .map(c => c.instance_type))];
            
            populateSelect('instance-select', instances);
            clearSelect('model-select');
            // Don't clear parameter selects when changing runtime
        }
        
        // Handle instance type selection change
        function onInstanceChange() {
            const runtime = document.getElementById('runtime-select').value;
            const instance = document.getElementById('instance-select').value;
            
            const models = combinations
                .filter(c => c.runtime === runtime && c.instance_type === instance)
                .map(c => c.model_name);
            
            populateSelect('model-select', models);
            // Don't clear parameter selects when changing instance type
        }
        
        // Handle model selection change
        async function onModelChange() {
            const runtime = document.getElementById('runtime-select').value;
            const instance = document.getElementById('instance-select').value;
            const model = document.getElementById('model-select').value;
            
            if (runtime && instance && model) {
                try {
                    const response = await fetch(`/api/parameters?runtime=${runtime}&instance_type=${instance}&model_name=${encodeURIComponent(model)}`);
                    const params = await response.json();
                    
                    // Use helper function to preserve token selections
                    preserveTokenSelections(params);
                } catch (error) {
                    showError('Failed to load parameters: ' + error.message);
                }
            }
        }
        
        // Utility function to populate select element
        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;
            
            // Clear existing options except the first one
            select.innerHTML = select.children[0].outerHTML;
            
            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });
            
            // Restore selection if still valid (convert to string for comparison)
            const currentValueStr = currentValue.toString();
            const optionStrings = options.map(opt => opt.toString());
            if (optionStrings.includes(currentValueStr)) {
                select.value = currentValue;
            }
        }
        
        // Utility function to clear select element
        function clearSelect(selectId) {
            const select = document.getElementById(selectId);
            select.innerHTML = select.children[0].outerHTML;
        }
        
        // Clear parameter selects (now unused, kept for compatibility)
        function clearParameterSelects() {
            // This function is now intentionally empty to preserve token selections
            // when switching between runtime/instance/model combinations
        }
        
        // Helper function to preserve token selections across model changes
        function preserveTokenSelections(newParams) {
            const tokenSelects = ['input-tokens', 'output-tokens', 'random-tokens'];
            const paramKeys = ['input_tokens', 'output_tokens', 'random_tokens'];
            
            tokenSelects.forEach((selectId, index) => {
                const select = document.getElementById(selectId);
                const currentValue = select.value;
                const paramKey = paramKeys[index];
                
                // Update options
                populateSelect(selectId, newParams[paramKey]);
                
                // Try to restore the previous selection if it exists in new options
                if (currentValue && newParams[paramKey].includes(parseInt(currentValue))) {
                    select.value = currentValue;
                }
            });
        }
        
        // Add current selection to comparison list
        function addToComparison() {
            const runtime = document.getElementById('runtime-select').value;
            const instance = document.getElementById('instance-select').value;
            const model = document.getElementById('model-select').value;
            const inputTokens = document.getElementById('input-tokens').value;
            const outputTokens = document.getElementById('output-tokens').value;
            const randomTokens = document.getElementById('random-tokens').value;
            
            if (!runtime || !instance || !model || !inputTokens || !outputTokens || !randomTokens) {
                showError('Please select all parameters before adding to comparison');
                return;
            }
            
            const combination = {
                runtime,
                instance_type: instance,
                model_name: model,
                input_tokens: parseInt(inputTokens),
                output_tokens: parseInt(outputTokens),
                random_tokens: parseInt(randomTokens)
            };
            
            // Check if combination already exists
            const exists = selectedCombinations.some(c => 
                c.runtime === combination.runtime &&
                c.instance_type === combination.instance_type &&
                c.model_name === combination.model_name &&
                c.input_tokens === combination.input_tokens &&
                c.output_tokens === combination.output_tokens &&
                c.random_tokens === combination.random_tokens
            );
            
            if (exists) {
                showError('This combination is already in the comparison list');
                return;
            }
            
            selectedCombinations.push(combination);
            updateComparisonList();
            
            // Auto-generate charts when combination is added
            generateCharts();
        }
        
        // Update the comparison list display
        function updateComparisonList() {
            const listContainer = document.getElementById('comparison-list');
            const itemsContainer = document.getElementById('comparison-items');
            
            if (selectedCombinations.length === 0) {
                listContainer.style.display = 'none';
                return;
            }
            
            listContainer.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            selectedCombinations.forEach((combo, index) => {
                const item = document.createElement('div');
                item.className = 'comparison-item';
                item.innerHTML = `
                    <span>${combo.runtime} - ${combo.instance_type} - ${combo.model_name} 
                    (in:${combo.input_tokens}, out:${combo.output_tokens}, rand:${combo.random_tokens})</span>
                    <button class="remove-btn" onclick="removeFromComparison(${index})">Remove</button>
                `;
                itemsContainer.appendChild(item);
            });
        }
        
        // Remove combination from comparison list
        function removeFromComparison(index) {
            selectedCombinations.splice(index, 1);
            updateComparisonList();
            
            // Auto-generate charts when combination is removed
            if (selectedCombinations.length > 0) {
                generateCharts();
            } else {
                clearCharts();
            }
        }
        
        // Clear all combinations
        function clearComparison() {
            selectedCombinations = [];
            updateComparisonList();
            clearCharts();
        }
        
        // Generate charts for selected combinations
        async function generateCharts() {
            if (selectedCombinations.length === 0) {
                clearCharts();
                return;
            }
            
            showLoading(true);
            clearError();
            
            try {
                const response = await fetch('/api/comparison-data', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        combinations: selectedCombinations
                    })
                });
                
                const data = await response.json();
                createCharts(data);
            } catch (error) {
                showError('Failed to generate charts: ' + error.message);
            } finally {
                showLoading(false);
            }
        }
        
        // Create all charts
        function createCharts(data) {
            clearCharts();
            
            const container = document.getElementById('charts-container');
            
            // Create chart containers
            const chartTypes = [
                { id: 'first-token-latency', title: 'First Token Latency vs Concurrency', metric: 'first_token_latency_mean', unit: 'seconds' },
                { id: 'output-tokens-per-second', title: 'Output Tokens Per Second vs Concurrency', metric: 'output_tokens_per_second_mean', unit: 'tokens/sec' },
                { id: 'server-throughput', title: 'Server Throughput vs Concurrency', metric: 'server_throughput', unit: 'total tokens/sec' },
                { id: 'end-to-end-latency', title: 'End-to-End Latency vs Concurrency', metric: 'end_to_end_latency_mean', unit: 'seconds' },
                { id: 'requests-per-second', title: 'Request Rate vs Concurrency', metric: 'requests_per_second', unit: 'requests/sec' },
                { id: 'success-rate', title: 'Success Rate vs Concurrency', metric: 'success_rate', unit: '%' }
            ];
            
            chartTypes.forEach(chartType => {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `
                    <div class="chart-title">${chartType.title}</div>
                    <div class="chart-container">
                        <canvas id="${chartType.id}"></canvas>
                    </div>
                `;
                container.appendChild(wrapper);
                
                createChart(chartType.id, chartType.title, chartType.metric, chartType.unit, data);
            });
        }
        
        // Create individual chart
        function createChart(canvasId, title, metric, unit, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            const datasets = data.map((item, index) => {
                const combo = item.combination;
                const chartData = item.data.sort((a, b) => a.processes - b.processes);
                
                // Convert success rate to percentage for display
                const processedData = chartData.map(d => ({
                    x: d.processes,
                    y: metric === 'success_rate' ? d[metric] * 100 : d[metric]
                }));
                
                // Create a more readable label with full information
                const runtimeName = combo.runtime; // Use full runtime name
                
                // Extract instance size (4x, 48x)
                const instanceSize = combo.instance_type.includes('4xlarge') ? '4x' : 
                                   combo.instance_type.includes('48xlarge') ? '48x' : 
                                   combo.instance_type.split('.')[1] || combo.instance_type;
                const instanceBase = combo.instance_type.split('.')[0];
                const instanceInfo = `${instanceBase}.${instanceSize}`;
                
                // Keep full model name
                const modelName = combo.model_name;
                
                // Include all token information: inputâ†’output(rand)
                const tokenInfo = `${combo.input_tokens}â†’${combo.output_tokens}(${combo.random_tokens})`;
                
                const label = `${runtimeName}/${instanceInfo}/${modelName} ${tokenInfo}`;
                
                return {
                    label: label,
                    data: processedData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                };
            });
            
            charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 8,
                                font: {
                                    size: 9
                                },
                                boxWidth: 8,
                                maxWidth: 300
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Concurrent Processes'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${title.split(' vs ')[0]} (${unit})`
                            },
                            // Set Y-axis range for success rate chart
                            ...(metric === 'success_rate' && {
                                min: 0,
                                max: 100,
                                ticks: {
                                    callback: function(value) {
                                        return value + '%';
                                    }
                                }
                            })
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        // Clear all charts
        function clearCharts() {
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};
            document.getElementById('charts-container').innerHTML = '';
        }
        
        // Show loading indicator
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }
        
        // Clear error message
        function clearError() {
            document.getElementById('error').style.display = 'none';
        }
        
        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>