<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Performance Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            background: white;
            border-right: 2px solid #eee;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .sidebar-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .sidebar-header h2 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 1.4em;
            font-weight: bold;
        }

        .copyleft {
            font-size: 11px;
            color: #666;
            line-height: 1.3;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
            text-align: center;
        }

        .copyleft a {
            color: #007bff;
            text-decoration: none;
        }

        .copyleft a:hover {
            text-decoration: underline;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }



        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .control-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        .control-group select,
        .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        .slider-group label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .button-group {
            display: flex;
            gap: 10px;
            align-items: end;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0056b3;
        }

        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #545b62;
        }

        .btn-success {
            background-color: #28a745;
            color: white;
        }

        .btn-success:hover {
            background-color: #1e7e34;
        }

        .comparison-list {
            margin: 20px 0;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
        }

        .comparison-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .comparison-item:last-child {
            border-bottom: none;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .chart-wrapper {
            background: white;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }

        .chart-container {
            position: relative;
            height: 420px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-style: italic;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
        }



        /* Tree structure styles */
        .tree-container {
            margin-bottom: 20px;
        }

        .tree-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
            margin: 0;
        }

        .tree-filter {
            position: relative;
            margin-bottom: 15px;
        }

        .filter-input {
            width: 100%;
            padding: 8px 30px 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        .filter-input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .filter-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 16px;
            color: #666;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .filter-clear:hover {
            background: #f0f0f0;
            color: #333;
        }

        .filter-clear:hidden {
            display: none;
        }

        .tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .tree-node {
            margin: 0;
            padding: 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            margin: 2px 0;
            transition: background-color 0.2s;
            user-select: none;
        }

        .tree-item:hover {
            background-color: #f8f9fa;
        }

        .tree-item.selected {
            background-color: #e3f2fd;
            color: #1976d2;
            font-weight: bold;
        }

        .tree-item.expandable {
            font-weight: 600;
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #666;
        }

        .tree-toggle.expanded::before {
            content: '▼';
        }

        .tree-toggle.collapsed::before {
            content: '▶';
        }

        .tree-toggle.leaf::before {
            content: '•';
            font-size: 8px;
        }

        .tree-children {
            list-style: none;
            padding-left: 24px;
            margin: 0;
            display: none;
        }

        .tree-children.expanded {
            display: block;
        }

        .tree-label {
            flex: 1;
            font-size: 13px;
        }

        .tree-count {
            font-size: 11px;
            color: #666;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
        }

        .tree-node.filtered-hidden {
            display: none;
        }

        .tree-item.filter-match {
            background-color: #fff3cd;
        }

        .selected-info {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #666;
        }

        .selected-info strong {
            color: #333;
        }

        .tree-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .refresh-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }

        .refresh-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .refresh-btn:active {
            background: #dee2e6;
            transform: scale(0.95);
        }

        .refresh-btn.loading {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .refresh-icon {
            font-size: 16px;
            color: #495057;
            transition: transform 0.3s;
        }

        .refresh-btn.loading .refresh-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>LLM Performance Visualization</h2>
        </div>

        <div class="tree-container">
            <div class="tree-header">
                <div class="tree-title">🚀 Runtime / Instance / Model</div>
                <button class="refresh-btn" id="refresh-tree" title="Refresh test results from disk">
                    <span class="refresh-icon">↻</span>
                </button>
            </div>
            <div class="tree-filter">
                <input type="text" id="tree-filter" class="filter-input" placeholder="Filter models..."
                    autocomplete="off">
                <button class="filter-clear" id="filter-clear" title="Clear filter">×</button>
            </div>
            <ul class="tree" id="runtime-tree">
                <!-- Tree structure will be populated here -->
            </ul>
        </div>

        <div id="selected-info" class="selected-info" style="display: none;">
            <strong>Selected:</strong><br>
            <span id="selected-text">None</span>
        </div>

        <div class="tree-container">
            <div class="tree-title">Token Configuration</div>
            <div class="slider-group">
                <label for="input-tokens">Input Tokens: <span id="input-tokens-value">-</span></label>
                <input type="range" id="input-tokens" class="slider" min="0" max="1000" value="0" disabled>
            </div>

            <div class="slider-group">
                <label for="output-tokens">Output Tokens: <span id="output-tokens-value">-</span></label>
                <input type="range" id="output-tokens" class="slider" min="0" max="1000" value="0" disabled>
            </div>

            <div class="slider-group">
                <label for="random-tokens">Random Tokens: <span id="random-tokens-value">-</span></label>
                <input type="range" id="random-tokens" class="slider" min="0" max="1000" value="0" disabled>
            </div>

            <div class="button-group" style="margin-top: 15px;">
                <button class="btn btn-primary" onclick="addToComparison()">Add to Comparison</button>
                <button class="btn btn-secondary" onclick="clearComparison()">Clear All</button>
            </div>
            
            <div class="button-group" style="margin-top: 10px;">
                <button class="btn btn-success" onclick="copyShareableUrl()" title="Copy shareable URL to clipboard">
                    📋 Share URL
                </button>
            </div>
        </div>

        <div id="comparison-list" class="comparison-list" style="display: none;">
            <h3>Selected Combinations:</h3>
            <div id="comparison-items"></div>
        </div>

        <div class="copyleft">
            <a href="https://github.com/yytdfc/llm-performance-viz"
                target="_blank">https://github.com/yytdfc/llm-performance-viz</a>
        </div>
    </div>

    <div class="main-content">


        <div id="loading" class="loading" style="display: none;">
            Loading data...
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="charts-container" class="charts-container">
            <!-- Charts will be generated here -->
        </div>
    </div>

    <script>
        // Global variables
        let treeData = [];
        let selectedCombinations = [];
        let charts = {};
        let currentSelection = null;

        // Color palette for different combinations
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
        ];

        // Initialize the application
        async function init() {
            try {
                await loadTreeStructure();
                setupFilterEventListeners();
                
                // Restore state from URL parameters after tree is loaded
                setTimeout(() => {
                    restoreStateFromUrl();
                }, 500);
            } catch (error) {
                showError('Failed to initialize application: ' + error.message);
            }
        }

        // Get API base path
        function getApiUrl(endpoint) {
            const basePath = window.API_BASE_PATH || '';
            return `${basePath}${endpoint}`;
        }

        // Load tree structure data
        async function loadTreeStructure() {
            const response = await fetch(getApiUrl('/api/tree-structure'));
            const data = await response.json();
            treeData = data.tree;
            renderTree();
        }

        // Refresh tree data from disk
        async function refreshTreeData() {
            const refreshBtn = document.getElementById('refresh-tree');
            const refreshIcon = refreshBtn.querySelector('.refresh-icon');

            try {
                // Show loading state
                refreshBtn.classList.add('loading');
                refreshBtn.disabled = true;

                // Clear current selection and comparisons
                currentSelection = null;
                selectedCombinations = [];
                updateSelectedInfo();
                updateComparisonList();
                clearCharts();

                // Reload tree structure
                await loadTreeStructure();

                // Clear any active filter
                const filterInput = document.getElementById('tree-filter');
                if (filterInput.value) {
                    filterInput.value = '';
                    filterTree('');
                    document.getElementById('filter-clear').style.display = 'none';
                }

                console.log('Tree data refreshed successfully');

            } catch (error) {
                showError('Failed to refresh tree data: ' + error.message);
            } finally {
                // Remove loading state
                refreshBtn.classList.remove('loading');
                refreshBtn.disabled = false;
            }
        }

        // Render the tree structure
        function renderTree() {
            const treeContainer = document.getElementById('runtime-tree');
            treeContainer.innerHTML = '';

            treeData.forEach(runtimeNode => {
                const runtimeElement = createTreeNode(runtimeNode, 0);
                treeContainer.appendChild(runtimeElement);
            });
        }

        // Create a tree node element
        function createTreeNode(node, level) {
            const li = document.createElement('li');
            li.className = 'tree-node';

            const item = document.createElement('div');
            item.className = 'tree-item';
            if (node.children && node.children.length > 0) {
                item.classList.add('expandable');
            }

            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            if (node.children && node.children.length > 0) {
                toggle.classList.add('expanded');
            } else {
                toggle.classList.add('leaf');
            }

            const label = document.createElement('span');
            label.className = 'tree-label';
            label.textContent = node.label;

            const count = document.createElement('span');
            count.className = 'tree-count';
            count.textContent = node.count;

            item.appendChild(toggle);
            item.appendChild(label);
            item.appendChild(count);

            // Add click handler
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                handleTreeItemClick(node, item, toggle);
            });

            li.appendChild(item);

            // Add children if they exist
            if (node.children && node.children.length > 0) {
                const childrenContainer = document.createElement('ul');
                childrenContainer.className = 'tree-children expanded';

                node.children.forEach(child => {
                    const childElement = createTreeNode(child, level + 1);
                    childrenContainer.appendChild(childElement);
                });

                li.appendChild(childrenContainer);
            }

            return li;
        }

        // Handle tree item click
        async function handleTreeItemClick(node, itemElement, toggleElement) {
            // Handle expansion/collapse for parent nodes
            if (node.children && node.children.length > 0) {
                const childrenContainer = itemElement.parentElement.querySelector('.tree-children');
                const isExpanded = childrenContainer.classList.contains('expanded');

                if (isExpanded) {
                    childrenContainer.classList.remove('expanded');
                    toggleElement.classList.remove('expanded');
                    toggleElement.classList.add('collapsed');
                } else {
                    childrenContainer.classList.add('expanded');
                    toggleElement.classList.remove('collapsed');
                    toggleElement.classList.add('expanded');
                }
            }

            // Handle selection for model nodes (leaf nodes)
            if (node.type === 'model') {
                // Clear previous selection
                document.querySelectorAll('.tree-item.selected').forEach(item => {
                    item.classList.remove('selected');
                });

                // Set new selection
                itemElement.classList.add('selected');
                currentSelection = {
                    runtime: node.runtime,
                    instance_type: node.instance_type,
                    model_name: node.model_name
                };

                // Update selected info display
                updateSelectedInfo();

                // Load token parameters for this selection
                await loadTokenParameters();
            }
        }

        // Update the selected info display
        function updateSelectedInfo() {
            const selectedInfo = document.getElementById('selected-info');
            const selectedText = document.getElementById('selected-text');

            if (currentSelection) {
                selectedText.innerHTML = `
                    <strong>Runtime:</strong> ${currentSelection.runtime}<br>
                    <strong>Instance:</strong> ${currentSelection.instance_type}<br>
                    <strong>Model:</strong> ${currentSelection.model_name}
                `;
                selectedInfo.style.display = 'block';
            } else {
                selectedInfo.style.display = 'none';
            }
        }

        // Load token parameters for the current selection
        async function loadTokenParameters() {
            if (!currentSelection) return;

            try {
                const response = await fetch(getApiUrl(`/api/parameters?runtime=${currentSelection.runtime}&instance_type=${currentSelection.instance_type}&model_name=${encodeURIComponent(currentSelection.model_name)}`));
                const params = await response.json();

                // Preserve current token selections
                preserveTokenSelections(params);
            } catch (error) {
                showError('Failed to load parameters: ' + error.message);
            }
        }

        // Helper function to preserve token selections across model changes
        function preserveTokenSelections(newParams) {
            const sliders = [
                { id: 'input-tokens', key: 'input_tokens', valueId: 'input-tokens-value' },
                { id: 'output-tokens', key: 'output_tokens', valueId: 'output-tokens-value' },
                { id: 'random-tokens', key: 'random_tokens', valueId: 'random-tokens-value' }
            ];

            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                const values = newParams[slider.key];

                if (values && values.length > 0) {
                    const minVal = Math.min(...values);
                    const maxVal = Math.max(...values);

                    // Enable slider and set range
                    sliderElement.disabled = false;
                    sliderElement.min = minVal;
                    sliderElement.max = maxVal;

                    // Try to preserve current value if it's within range
                    const currentValue = parseInt(sliderElement.value);
                    if (currentValue >= minVal && currentValue <= maxVal && values.includes(currentValue)) {
                        sliderElement.value = currentValue;
                    } else {
                        // Set to preferred default values if available, otherwise first available value
                        let defaultValue;
                        if (slider.id === 'input-tokens') {
                            defaultValue = values.includes(1600) ? 1600 : values[0];
                        } else if (slider.id === 'output-tokens') {
                            defaultValue = values.includes(400) ? 400 : values[0];
                        } else if (slider.id === 'random-tokens') {
                            defaultValue = values.includes(1600) ? 1600 : values[0];
                        } else {
                            defaultValue = values[0];
                        }
                        sliderElement.value = defaultValue;
                    }

                    // Update display value
                    valueElement.textContent = sliderElement.value;

                    // Store available values for validation
                    sliderElement.availableValues = values;

                    // Store original values for random tokens constraint logic
                    if (slider.id === 'random-tokens') {
                        sliderElement.originalAvailableValues = [...values];
                    }
                } else {
                    // Disable slider if no values available
                    sliderElement.disabled = true;
                    sliderElement.value = 0;
                    valueElement.textContent = '-';
                    sliderElement.availableValues = [];
                }
            });

            // Set up event listeners for sliders
            setupSliderEventListeners();

            // Update random tokens max based on current input tokens
            updateRandomTokensMax();
        }

        // Setup event listeners for sliders
        function setupSliderEventListeners() {
            const inputTokensSlider = document.getElementById('input-tokens');
            const outputTokensSlider = document.getElementById('output-tokens');
            const randomTokensSlider = document.getElementById('random-tokens');

            // Remove existing event listeners to avoid duplicates
            inputTokensSlider.oninput = null;
            outputTokensSlider.oninput = null;
            randomTokensSlider.oninput = null;

            // Input tokens slider
            inputTokensSlider.addEventListener('input', function () {
                if (this.availableValues && this.availableValues.length > 0) {
                    const value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                    document.getElementById('input-tokens-value').textContent = value;
                    updateRandomTokensMax();
                }
            });

            // Output tokens slider
            outputTokensSlider.addEventListener('input', function () {
                if (this.availableValues && this.availableValues.length > 0) {
                    const value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                    document.getElementById('output-tokens-value').textContent = value;
                }
            });

            // Random tokens slider
            randomTokensSlider.addEventListener('input', function () {
                if (this.availableValues && this.availableValues.length > 0) {
                    const value = findClosestAvailableValue(this.value, this.availableValues);
                    this.value = value;
                    document.getElementById('random-tokens-value').textContent = value;
                }
            });
        }

        // Find closest available value from the allowed values
        function findClosestAvailableValue(targetValue, availableValues) {
            if (!availableValues || availableValues.length === 0) return targetValue;

            const target = parseInt(targetValue);
            return availableValues.reduce((prev, curr) => {
                return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;
            });
        }

        // Update random tokens max value based on input tokens
        function updateRandomTokensMax() {
            const inputTokensSlider = document.getElementById('input-tokens');
            const randomTokensSlider = document.getElementById('random-tokens');
            const randomTokensValue = document.getElementById('random-tokens-value');

            if (!inputTokensSlider.disabled && !randomTokensSlider.disabled) {
                const inputTokensValue = parseInt(inputTokensSlider.value);

                // Get original available values (stored when model was selected)
                const originalAvailableValues = randomTokensSlider.originalAvailableValues || randomTokensSlider.availableValues || [];

                // Filter available values to be <= input tokens
                const filteredValues = originalAvailableValues.filter(val => val <= inputTokensValue);

                if (filteredValues.length > 0) {
                    const newMin = Math.min(...filteredValues);
                    const newMax = Math.max(...filteredValues);

                    // Update slider range
                    randomTokensSlider.min = newMin;
                    randomTokensSlider.max = newMax;
                    randomTokensSlider.disabled = false;

                    // Update available values for this constraint
                    randomTokensSlider.availableValues = filteredValues;

                    // Adjust current value if it needs to be clipped or is invalid
                    const currentValue = parseInt(randomTokensSlider.value);
                    let needsAdjustment = false;
                    let newValue = currentValue;

                    // Check if current value exceeds input tokens constraint
                    if (currentValue > inputTokensValue) {
                        // Clip to the largest available value that's <= input tokens
                        newValue = Math.max(...filteredValues);
                        needsAdjustment = true;
                    }
                    // Check if current value is outside the valid range
                    else if (currentValue > newMax || currentValue < newMin) {
                        newValue = Math.min(Math.max(currentValue, newMin), newMax);
                        needsAdjustment = true;
                    }
                    // Check if current value is not in the available values list
                    else if (!filteredValues.includes(currentValue)) {
                        newValue = findClosestAvailableValue(currentValue, filteredValues);
                        needsAdjustment = true;
                    }

                    if (needsAdjustment) {
                        randomTokensSlider.value = newValue;
                        randomTokensValue.textContent = newValue;
                    }
                } else {
                    // No valid values, disable random tokens
                    randomTokensSlider.disabled = true;
                    randomTokensValue.textContent = '-';
                }
            }
        }



        // Utility function to populate select element
        function populateSelect(selectId, options) {
            const select = document.getElementById(selectId);
            const currentValue = select.value;

            // Clear existing options except the first one
            select.innerHTML = select.children[0].outerHTML;

            options.forEach(option => {
                const optionElement = document.createElement('option');
                optionElement.value = option;
                optionElement.textContent = option;
                select.appendChild(optionElement);
            });

            // Restore selection if still valid
            const currentValueStr = currentValue.toString();
            const optionStrings = options.map(opt => opt.toString());
            if (optionStrings.includes(currentValueStr)) {
                select.value = currentValue;
            }
        }

        // Add current selection to comparison list
        function addToComparison() {
            if (!currentSelection) {
                showError('Please select a model from the tree first');
                return;
            }

            const inputTokensSlider = document.getElementById('input-tokens');
            const outputTokensSlider = document.getElementById('output-tokens');
            const randomTokensSlider = document.getElementById('random-tokens');

            if (inputTokensSlider.disabled || outputTokensSlider.disabled || randomTokensSlider.disabled) {
                showError('Please ensure all token parameters are configured');
                return;
            }

            const inputTokens = parseInt(inputTokensSlider.value);
            const outputTokens = parseInt(outputTokensSlider.value);
            const randomTokens = parseInt(randomTokensSlider.value);

            if (!inputTokens || !outputTokens || randomTokens === undefined) {
                showError('Please configure all token parameters before adding to comparison');
                return;
            }

            const combination = {
                runtime: currentSelection.runtime,
                instance_type: currentSelection.instance_type,
                model_name: currentSelection.model_name,
                input_tokens: inputTokens,
                output_tokens: outputTokens,
                random_tokens: randomTokens
            };

            // Check if combination already exists
            const exists = selectedCombinations.some(c =>
                c.runtime === combination.runtime &&
                c.instance_type === combination.instance_type &&
                c.model_name === combination.model_name &&
                c.input_tokens === combination.input_tokens &&
                c.output_tokens === combination.output_tokens &&
                c.random_tokens === combination.random_tokens
            );

            if (exists) {
                showError('This combination is already in the comparison list');
                return;
            }

            selectedCombinations.push(combination);
            updateComparisonList();

            // Auto-generate charts when combination is added
            generateCharts();
            
            // Update URL with new state
            updateUrlWithState();
        }

        // Update the comparison list display
        function updateComparisonList() {
            const listContainer = document.getElementById('comparison-list');
            const itemsContainer = document.getElementById('comparison-items');

            if (selectedCombinations.length === 0) {
                listContainer.style.display = 'none';
                return;
            }

            listContainer.style.display = 'block';
            itemsContainer.innerHTML = '';

            selectedCombinations.forEach((combo, index) => {
                const item = document.createElement('div');
                item.className = 'comparison-item';
                item.innerHTML = `
                    <span>${combo.runtime} - ${combo.instance_type} - ${combo.model_name} 
                    (in:${combo.input_tokens}, out:${combo.output_tokens}, rand:${combo.random_tokens})</span>
                    <button class="remove-btn" onclick="removeFromComparison(${index})">Remove</button>
                `;
                itemsContainer.appendChild(item);
            });
        }

        // Remove combination from comparison list
        function removeFromComparison(index) {
            selectedCombinations.splice(index, 1);
            updateComparisonList();

            // Auto-generate charts when combination is removed
            if (selectedCombinations.length > 0) {
                generateCharts();
            } else {
                clearCharts();
            }
            
            // Update URL with new state
            updateUrlWithState();
        }

        // Clear all combinations
        function clearComparison() {
            selectedCombinations = [];
            updateComparisonList();
            clearCharts();
            
            // Update URL with new state
            updateUrlWithState();
        }

        // Generate charts for selected combinations
        async function generateCharts() {
            if (selectedCombinations.length === 0) {
                clearCharts();
                return;
            }

            showLoading(true);
            clearError();

            try {
                const response = await fetch(getApiUrl('/api/comparison-data'), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        combinations: selectedCombinations
                    })
                });

                const data = await response.json();
                createCharts(data);
            } catch (error) {
                showError('Failed to generate charts: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Create all charts
        function createCharts(data) {
            clearCharts();

            const container = document.getElementById('charts-container');

            // Create chart containers
            const chartTypes = [
                { id: 'first-token-latency', title: 'First Token Latency vs Concurrency', metric: 'first_token_latency_mean', unit: 'seconds' },
                { id: 'output-tokens-per-second', title: 'Output Tokens Per Second vs Concurrency', metric: 'output_tokens_per_second_mean', unit: 'tokens/sec' },
                { id: 'server-throughput', title: 'Server Throughput vs Concurrency', metric: 'server_throughput', unit: 'total tokens/sec' },
                { id: 'end-to-end-latency', title: 'End-to-End Latency vs Concurrency', metric: 'end_to_end_latency_mean', unit: 'seconds' },
                { id: 'requests-per-second', title: 'Request Rate vs Concurrency', metric: 'requests_per_second', unit: 'requests/sec' },
                { id: 'success-rate', title: 'Success Rate vs Concurrency', metric: 'success_rate', unit: '%' }
            ];

            chartTypes.forEach(chartType => {
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.innerHTML = `
                    <div class="chart-title">${chartType.title}</div>
                    <div class="chart-container">
                        <canvas id="${chartType.id}"></canvas>
                    </div>
                `;
                container.appendChild(wrapper);

                createChart(chartType.id, chartType.title, chartType.metric, chartType.unit, data);
            });
        }

        // Create individual chart
        function createChart(canvasId, title, metric, unit, data) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            const datasets = data.map((item, index) => {
                const combo = item.combination;
                const chartData = item.data.sort((a, b) => a.processes - b.processes);

                // Convert success rate to percentage for display
                const processedData = chartData.map(d => ({
                    x: d.processes,
                    y: metric === 'success_rate' ? d[metric] * 100 : d[metric]
                }));

                // Create a more readable label with full information
                const runtimeName = combo.runtime;

                // Extract instance size (4x, 48x)
                const instanceSize = combo.instance_type.includes('4xlarge') ? '4x' :
                    combo.instance_type.includes('48xlarge') ? '48x' :
                        combo.instance_type.split('.')[1] || combo.instance_type;
                const instanceBase = combo.instance_type.split('.')[0];
                const instanceInfo = `${instanceBase}.${instanceSize}`;

                // Keep full model name
                const modelName = combo.model_name;

                // Include all token information: input(rand)→output
                const tokenInfo = `${combo.input_tokens}(${combo.random_tokens})→${combo.output_tokens}`;

                const label = `${runtimeName}/${instanceInfo}/${modelName} ${tokenInfo}`;

                return {
                    label: label,
                    data: processedData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                };
            });

            charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 8,
                                font: {
                                    size: 9
                                },
                                boxWidth: 8,
                                maxWidth: 300
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Concurrent Processes'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `${title.split(' vs ')[0]} (${unit})`
                            },
                            // Set Y-axis range for success rate chart
                            ...(metric === 'success_rate' && {
                                min: 0,
                                max: 100
                            })
                        }
                    }
                }
            });
        }

        // Clear all charts
        function clearCharts() {
            Object.values(charts).forEach(chart => {
                if (chart) {
                    chart.destroy();
                }
            });
            charts = {};
            document.getElementById('charts-container').innerHTML = '';
        }

        // Show loading indicator
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        // Clear error message
        function clearError() {
            document.getElementById('error').style.display = 'none';
        }

        // Setup filter event listeners
        function setupFilterEventListeners() {
            const filterInput = document.getElementById('tree-filter');
            const filterClear = document.getElementById('filter-clear');
            const refreshBtn = document.getElementById('refresh-tree');

            // Filter input event
            filterInput.addEventListener('input', function () {
                const filterText = this.value.trim();
                filterTree(filterText);

                // Show/hide clear button
                if (filterText) {
                    filterClear.style.display = 'flex';
                } else {
                    filterClear.style.display = 'none';
                }
                
                // Update URL with filter state
                updateUrlWithState();
            });

            // Clear button event
            filterClear.addEventListener('click', function () {
                filterInput.value = '';
                filterTree('');
                this.style.display = 'none';
                filterInput.focus();
                
                // Update URL with cleared filter
                updateUrlWithState();
            });

            // Refresh button event
            refreshBtn.addEventListener('click', async function () {
                await refreshTreeData();
            });

            // Initially hide clear button
            filterClear.style.display = 'none';
        }

        // Filter tree based on search text
        function filterTree(filterText) {
            const tree = document.getElementById('runtime-tree');
            const allNodes = tree.querySelectorAll('.tree-node');

            if (!filterText) {
                // Show all nodes and remove highlights
                allNodes.forEach(node => {
                    node.classList.remove('filtered-hidden');
                    const item = node.querySelector('.tree-item');
                    if (item) {
                        item.classList.remove('filter-match');
                    }
                });
                return;
            }

            const searchText = filterText.toLowerCase();

            // First pass: mark matching nodes
            const matchingNodes = new Set();
            allNodes.forEach(node => {
                const item = node.querySelector('.tree-item');
                const label = item.querySelector('.tree-label');

                if (label && label.textContent.toLowerCase().includes(searchText)) {
                    matchingNodes.add(node);
                    item.classList.add('filter-match');

                    // Mark all parent nodes as matching
                    let parent = node.parentElement;
                    while (parent && parent.classList.contains('tree-children')) {
                        const parentNode = parent.parentElement;
                        if (parentNode && parentNode.classList.contains('tree-node')) {
                            matchingNodes.add(parentNode);
                            parent = parentNode.parentElement;
                        } else {
                            break;
                        }
                    }

                    // Mark all child nodes as matching
                    const childNodes = node.querySelectorAll('.tree-node');
                    childNodes.forEach(child => matchingNodes.add(child));
                } else {
                    item.classList.remove('filter-match');
                }
            });

            // Second pass: show/hide nodes based on matches
            allNodes.forEach(node => {
                if (matchingNodes.has(node)) {
                    node.classList.remove('filtered-hidden');

                    // Auto-expand parent nodes that contain matches
                    const childrenContainer = node.querySelector('.tree-children');
                    const toggle = node.querySelector('.tree-toggle');
                    if (childrenContainer && toggle && !toggle.classList.contains('leaf')) {
                        childrenContainer.classList.add('expanded');
                        toggle.classList.remove('collapsed');
                        toggle.classList.add('expanded');
                    }
                } else {
                    node.classList.add('filtered-hidden');
                }
            });
        }

        // URL State Management
        function updateUrlWithState() {
            const url = new URL(window.location);
            
            // Clear existing parameters
            url.searchParams.delete('combinations');
            url.searchParams.delete('filter');
            
            // Add current combinations
            if (selectedCombinations.length > 0) {
                const combinationsData = selectedCombinations.map(combo => ({
                    r: combo.runtime,
                    i: combo.instance_type,
                    m: combo.model_name,
                    it: combo.input_tokens,
                    ot: combo.output_tokens,
                    rt: combo.random_tokens
                }));
                url.searchParams.set('combinations', btoa(JSON.stringify(combinationsData)));
            }
            
            // Add current filter
            const filterInput = document.getElementById('tree-filter');
            if (filterInput && filterInput.value.trim()) {
                url.searchParams.set('filter', filterInput.value.trim());
            }
            
            // Update URL without page reload
            window.history.replaceState({}, '', url);
        }
        
        function restoreStateFromUrl() {
            const url = new URL(window.location);
            
            // Restore filter
            const filter = url.searchParams.get('filter');
            if (filter) {
                const filterInput = document.getElementById('tree-filter');
                if (filterInput) {
                    filterInput.value = filter;
                    filterTree(filter);
                    document.getElementById('filter-clear').style.display = 'flex';
                }
            }
            
            // Restore combinations
            const combinationsParam = url.searchParams.get('combinations');
            if (combinationsParam) {
                try {
                    const combinationsData = JSON.parse(atob(combinationsParam));
                    
                    // Convert back to full format
                    const combinations = combinationsData.map(combo => ({
                        runtime: combo.r,
                        instance_type: combo.i,
                        model_name: combo.m,
                        input_tokens: combo.it,
                        output_tokens: combo.ot,
                        random_tokens: combo.rt
                    }));
                    
                    selectedCombinations = combinations;
                    updateComparisonList();
                    
                    // Generate charts if combinations exist
                    if (selectedCombinations.length > 0) {
                        generateCharts();
                    }
                } catch (error) {
                    console.warn('Failed to restore combinations from URL:', error);
                }
            }
        }
        
        function copyShareableUrl() {
            updateUrlWithState();
            const url = window.location.href;
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(url).then(() => {
                    showSuccess('Shareable URL copied to clipboard!');
                }).catch(() => {
                    fallbackCopyUrl(url);
                });
            } else {
                fallbackCopyUrl(url);
            }
        }
        
        function fallbackCopyUrl(url) {
            // Fallback for older browsers or non-HTTPS
            const textArea = document.createElement('textarea');
            textArea.value = url;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showSuccess('Shareable URL copied to clipboard!');
            } catch (err) {
                showError('Failed to copy URL. Please copy manually: ' + url);
            }
            
            document.body.removeChild(textArea);
        }
        
        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #d4edda;
                color: #155724;
                padding: 15px;
                border-radius: 4px;
                border: 1px solid #c3e6cb;
                z-index: 1000;
                max-width: 300px;
            `;
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                document.body.removeChild(successDiv);
            }, 3000);
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>